{"version":3,"sources":["/home/circleci/project/packages/webviz-core/src/components/ReactChartjs/ChartJSWorker.js","/home/circleci/project/packages/webviz-core/src/components/ReactChartjs/ChartJSManager.js","/home/circleci/project/packages/webviz-core/src/util/installChartjs.js","/home/circleci/project/packages/webviz-core/src/util/multicolorLineChart.js"],"names":["inWorkerEnvironment","global","postMessage","onmessage","hasInstalledChartjs","constructor","rpc","Chart","this","_managersById","_rpc","Rpc","setupWorker","receive","args","manager","ChartJSManager","id","getScaleBounds","doZoom","resetZoomDelta","doPan","resetPanDelta","update","resetZoom","result","destroy","getElementAtXAxis","getDatalabelAtEvent","hideAllTicksScaleCallback","hideFirstAndLastTicksScaleCallback","value","index","values","length","Math","round","displayTicksInSecondsCallback","mapChartElementToEventElement","chartInstance","item","data","datasets","_datasetIndex","_index","view","_view","datasetKeyProvider","d","label","node","type","options","scaleOptions","devicePixelRatio","_node","_addFunctionsToConfig","plugins","_chartInstance","zoomOptions","percentZoomX","percentZoomY","focalPoint","whichAxesParam","panOptions","deltaX","deltaY","helpers","configMerge","currentDatasets","_getCurrentDatasets","nextDatasets","_checkDatasets","currentDatasetsIndexed","config","map","next","current","splice","forEach","point","pid","otherDatasetProps","otherDataProps","event","pointElements","getElementsAtEventForMode","xAxisElements","intersect","nearestXAxisElement","find","some","item2","chartDatalabel","$datalabels","getLabelAtEvent","context","$context","dataset","dataIndex","datalabels","formatter","_context","staticColor","color","labelColor","scale","scales","yAxes","fixedYAxisWidth","afterFit","scaleInstance","width","ticks","yAxisTicks","callback","xAxes","xAxisTicks","ChartJSChart","annotationPlugin","require","datalabelPlugin","register","defaults","display","count","Error","multicolorLine","scatter","controllers","extend","draw","ease","startIndex","meta","getMeta","points","colors","getDataset","area","chart","chartArea","multicolorLineYOffset","_children","originalY","y","originalDatasets","filter","isNaN","setColor","newColor","borderColor","i","slice","prototype","call"],"mappings":"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","file":"main-thread-chartjs.js","sourcesContent":["// @flow\n//\n//  Copyright (c) 2018-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport Chart from \"chart.js\";\n\nimport ChartJSManager from \"./ChartJSManager\";\nimport type { RpcLike } from \"webviz-core/src/util/FakeRpc\";\nimport installChartjs from \"webviz-core/src/util/installChartjs\";\nimport Rpc from \"webviz-core/src/util/Rpc\";\nimport { setupWorker } from \"webviz-core/src/util/RpcUtils\";\n\nconst inWorkerEnvironment = global.postMessage && !global.onmessage;\n\nlet hasInstalledChartjs = false;\n\nexport default class ChartJSWorker {\n  _rpc: RpcLike;\n  _managersById: { [string]: ChartJSManager };\n\n  constructor(rpc: RpcLike) {\n    if (!hasInstalledChartjs) {\n      installChartjs(Chart);\n      hasInstalledChartjs = true;\n    }\n    this._managersById = {};\n\n    if (process.env.NODE_ENV !== \"test\" && inWorkerEnvironment && this._rpc instanceof Rpc) {\n      setupWorker(this._rpc);\n    }\n\n    rpc.receive(\"initialize\", (args) => {\n      const manager = new ChartJSManager(args);\n      this._managersById[args.id] = manager;\n      return this._managersById[args.id].getScaleBounds();\n    });\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"doZoom\", (args) => this._managersById[args.id]?.doZoom(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"resetZoomDelta\", (args) => this._managersById[args.id]?.resetZoomDelta(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"doPan\", (args) => this._managersById[args.id]?.doPan(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"resetPanDelta\", (args) => this._managersById[args.id]?.resetPanDelta(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"update\", (args) => this._managersById[args.id]?.update(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"resetZoom\", (args) => this._managersById[args.id]?.resetZoom(args));\n    rpc.receive(\"destroy\", (args) => {\n      const manager = this._managersById[args.id];\n      if (manager) {\n        const result = manager.destroy(args);\n        delete this._managersById[args.id];\n        return result;\n      }\n    });\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"getElementAtXAxis\", (args) => this._managersById[args.id]?.getElementAtXAxis(args));\n    // $FlowFixMe flow doesn't like function calls in optional chains\n    rpc.receive(\"getDatalabelAtEvent\", (args) => this._managersById[args.id]?.getDatalabelAtEvent(args));\n  }\n}\n","// @flow\n//\n//  Copyright (c) 2018-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport Chart from \"chart.js\";\nimport keyBy from \"lodash/keyBy\";\nimport omit from \"lodash/omit\";\n\nimport {\n  type ZoomOptions,\n  type PanOptions,\n  doZoom,\n  doPan,\n  resetPanDelta,\n  resetZoomDelta,\n  resetZoom,\n  getScaleBounds,\n} from \"./zoomAndPanHelpers\";\n\ntype XAxisTicks = \"follow\" | \"displayXAxesTicksInSeconds\";\n\n// These are options that we pass our worker. We have to pass this as a separate object instead of as part of the\n// config because they can only be set using a callback function, which we can't pass across worker boundaries.\nexport type ScaleOptions = {|\n  // Sets y-axis labels to a fixed width, so that vertically-aligned charts can be directly compared.\n  fixedYAxisWidth?: ?number,\n  // We might want to hide just the first and last because they can overlap with other labels or have long decimal\n  // points.\n  yAxisTicks?: \"show\" | \"hide\" | \"hideFirstAndLast\",\n  // Display the x-axes with a seconds unit, eg \"1 s\"\n  xAxisTicks?: ?XAxisTicks,\n|};\n\nfunction hideAllTicksScaleCallback() {\n  return \"\";\n}\n\nfunction hideFirstAndLastTicksScaleCallback(value: number, index: number, values: number[]) {\n  if (index === 0 || index === values.length - 1) {\n    // First and last labels sometimes get super long rounding errors when zooming.\n    // This fixes that.\n    return \"\";\n  }\n  // Also round the scale value.\n  return `${Math.round(value * 1000) / 1000}`;\n}\n\nfunction displayTicksInSecondsCallback(value: number) {\n  return `${Math.round(value * 1000) / 1000} s`;\n}\n\nfunction mapChartElementToEventElement(chartInstance, item) {\n  return {\n    // It's annoying to have to rely on internal APIs like this, but there's literally no other way and the help\n    // documents themselves say to do this: https://www.chartjs.org/docs/latest/developers/api.html#getelementatevente\n    // eslint-disable-next-line no-underscore-dangle\n    data: chartInstance.data.datasets[item._datasetIndex]?.data[item._index],\n    // eslint-disable-next-line no-underscore-dangle\n    view: item._view,\n  };\n}\n\nconst datasetKeyProvider = (d) => d.label;\n\ntype ChartInstance = any;\n// This type is not yet in Flow, so temporarily type it this way.\ntype OffscreenCanvas = HTMLCanvasElement;\n\nexport default class ChartJSManager {\n  id: string;\n  _node: OffscreenCanvas;\n  _chartInstance: ?ChartInstance;\n\n  constructor({\n    id,\n    node,\n    type,\n    data,\n    options,\n    scaleOptions,\n    devicePixelRatio,\n  }: {\n    id: string,\n    node: OffscreenCanvas,\n    type: any,\n    data: any,\n    options: any,\n    scaleOptions: ?ScaleOptions,\n    devicePixelRatio: number,\n  }) {\n    this.id = id;\n    this._node = node;\n    const plugins = {};\n    const chartInstance = new Chart(node, {\n      type,\n      data,\n      options: { ...this._addFunctionsToConfig(options, scaleOptions), devicePixelRatio },\n      plugins,\n    });\n    this._chartInstance = chartInstance;\n  }\n\n  getScaleBounds() {\n    const chartInstance = this._chartInstance;\n    if (!chartInstance) {\n      return;\n    }\n\n    return getScaleBounds(chartInstance);\n  }\n\n  doZoom({\n    zoomOptions,\n    percentZoomX,\n    percentZoomY,\n    focalPoint,\n    whichAxesParam,\n  }: {\n    zoomOptions: ZoomOptions,\n    percentZoomX: number,\n    percentZoomY: number,\n    focalPoint?: { x: number, y: number },\n    whichAxesParam?: string,\n  }) {\n    const chartInstance = this._chartInstance;\n    if (!chartInstance) {\n      return;\n    }\n\n    doZoom(this.id, chartInstance, zoomOptions, percentZoomX, percentZoomY, focalPoint, whichAxesParam);\n    return getScaleBounds(chartInstance);\n  }\n\n  resetZoomDelta() {\n    const chartInstance = this._chartInstance;\n    if (!chartInstance) {\n      return;\n    }\n\n    resetZoomDelta(this.id);\n  }\n\n  doPan({ panOptions, deltaX, deltaY }: { panOptions: PanOptions, deltaX: number, deltaY: number }) {\n    const chartInstance = this._chartInstance;\n    if (!chartInstance) {\n      return;\n    }\n\n    doPan(this.id, chartInstance, panOptions, deltaX, deltaY);\n    return getScaleBounds(chartInstance);\n  }\n\n  resetPanDelta() {\n    resetPanDelta(this.id);\n  }\n\n  update({ data, options, scaleOptions }: { data: any, options: any, scaleOptions: ?ScaleOptions }) {\n    const chartInstance = this._chartInstance;\n\n    if (!chartInstance) {\n      return;\n    }\n\n    if (options) {\n      options = this._addFunctionsToConfig(options, scaleOptions);\n      chartInstance.options = Chart.helpers.configMerge(chartInstance.options, options);\n    }\n\n    // Pipe datasets to chart instance datasets enabling\n    // seamless transitions\n    const currentDatasets = this._getCurrentDatasets();\n    const nextDatasets = (data && data.datasets) || [];\n    this._checkDatasets(currentDatasets);\n\n    const currentDatasetsIndexed = keyBy(currentDatasets, datasetKeyProvider);\n\n    // We can safely replace the dataset array, as long as we retain the _meta property\n    // on each dataset.\n    chartInstance.config.data.datasets = nextDatasets.map((next) => {\n      const current = currentDatasetsIndexed[datasetKeyProvider(next)];\n\n      if (current && current.type === next.type && next.data) {\n        // Be robust to no data. Relevant for other update mechanisms as in chartjs-plugin-streaming.\n        // The data array must be edited in place. As chart.js adds listeners to it.\n        current.data.splice(next.data.length);\n        next.data.forEach((point, pid) => {\n          current.data[pid] = next.data[pid];\n        });\n        const otherDatasetProps = omit(next, \"data\");\n        // Merge properties. Notice a weakness here. If a property is removed\n        // from next, it will be retained by current and never disappears.\n        // Workaround is to set value to null or undefined in next.\n        return {\n          ...current,\n          ...otherDatasetProps,\n        };\n      }\n      return next;\n    });\n\n    const otherDataProps = omit(data, \"datasets\");\n\n    chartInstance.config.data = {\n      ...chartInstance.config.data,\n      ...otherDataProps,\n    };\n\n    chartInstance.update();\n\n    return getScaleBounds(chartInstance);\n  }\n\n  resetZoom() {\n    const chartInstance = this._chartInstance;\n    if (chartInstance) {\n      resetZoom(this.id, chartInstance);\n    }\n\n    return getScaleBounds(chartInstance);\n  }\n\n  destroy() {\n    const chartInstance = this._chartInstance;\n    if (chartInstance) {\n      chartInstance.destroy();\n    }\n    this._chartInstance = null;\n  }\n\n  // Get the closest element at the same x-axis value as the cursor.\n  // This is a somewhat complex function because we attempt to copy the same behavior that the built-in tooltips have\n  // for Chart.js without a direct API for it.\n  getElementAtXAxis({ event }: { event: Event }) {\n    const chartInstance = this._chartInstance;\n    if (chartInstance) {\n      // Elements directly under the cursor.\n      const pointElements = chartInstance.getElementsAtEventForMode(event, \"point\");\n\n      if (pointElements.length) {\n        // If we have an element directly under the cursor, return it.\n        return mapChartElementToEventElement(chartInstance, pointElements[0]);\n      }\n\n      // Elements near the x-axis position of the cursor.\n      const xAxisElements = chartInstance.getElementsAtEventForMode(event, \"x\", { intersect: false });\n      if (xAxisElements.length) {\n        // The nearest elements to the cursor, regardless of how close they are.\n        const nearestElements = chartInstance.getElementsAtEventForMode(event, \"nearest\", { intersect: false });\n        const nearestXAxisElement = nearestElements.find((item) =>\n          // eslint-disable-next-line no-underscore-dangle\n          xAxisElements.some((item2) => item._index === item2._index && item._datasetIndex === item2._datasetIndex)\n        );\n        // If we have elements on the x-axis, return the nearest element if we can find it.\n        if (nearestXAxisElement) {\n          return mapChartElementToEventElement(chartInstance, nearestXAxisElement);\n        }\n        // Otherwise just return the first element on the x-axis.\n        return mapChartElementToEventElement(chartInstance, xAxisElements[0]);\n      }\n    }\n  }\n\n  getDatalabelAtEvent({ event }: { event: Event }) {\n    const chartInstance = this._chartInstance;\n    if (chartInstance) {\n      const chartDatalabel = chartInstance.$datalabels.getLabelAtEvent(event);\n      if (chartDatalabel) {\n        const context = chartDatalabel.$context;\n        return context.dataset.data[context.dataIndex];\n      }\n    }\n  }\n\n  _addFunctionsToConfig(config: any, scaleOptions: ?ScaleOptions) {\n    if (config && config.plugins.datalabels) {\n      // This controls which datalabels are displayed. Only display labels for datapoints that include a \"label\"\n      // property.\n      config.plugins.datalabels.formatter = (value: any, _context: any) => {\n        const label = value?.label;\n        // We have to return \"null\" if we don't want this label to be displayed. Returning \"undefined\" falls back to the\n        // default formatting.\n        return label != null ? label : null;\n      };\n      // Override color so that it can be set per-dataset.\n      const staticColor = config.plugins.datalabels.color || \"white\";\n      config.plugins.datalabels.color = (context: any) => {\n        const value = context.dataset.data[context.dataIndex];\n        return value?.labelColor || staticColor;\n      };\n    }\n\n    if (scaleOptions) {\n      for (const scale of config.scales.yAxes) {\n        if (scaleOptions.fixedYAxisWidth != null) {\n          scale.afterFit = (scaleInstance: any) => {\n            scaleInstance.width = scaleOptions.fixedYAxisWidth;\n          };\n        }\n        scale.ticks = scale.ticks || {};\n        if (scaleOptions.yAxisTicks === \"hide\") {\n          scale.ticks.callback = hideAllTicksScaleCallback;\n        } else if (scaleOptions.yAxisTicks === \"hideFirstAndLast\") {\n          scale.ticks.callback = hideFirstAndLastTicksScaleCallback;\n        }\n      }\n\n      for (const scale of config.scales.xAxes) {\n        scale.ticks = scale.ticks || {};\n        if (scaleOptions.xAxisTicks) {\n          if (scaleOptions.xAxisTicks === \"displayXAxesTicksInSeconds\") {\n            scale.ticks.callback = displayTicksInSecondsCallback;\n          } else {\n            scale.ticks.callback = hideFirstAndLastTicksScaleCallback;\n          }\n        }\n      }\n    }\n\n    return config;\n  }\n\n  _checkDatasets(datasets: any[]) {\n    const isDev = process.env.NODE_ENV !== \"production\" && process.env.NODE_ENV !== \"prod\";\n    const multipleDatasets = datasets.length > 1;\n\n    if (isDev && multipleDatasets) {\n      let shouldWarn = false;\n      datasets.forEach((dataset) => {\n        if (!dataset.label) {\n          shouldWarn = true;\n        }\n      });\n\n      if (shouldWarn) {\n        console.error(\n          '[ChartJSManager] Warning: Each dataset needs a unique key. By default, the \"label\" property on each dataset is used.'\n        );\n      }\n    }\n  }\n\n  _getCurrentDatasets() {\n    return (this._chartInstance && this._chartInstance.config.data && this._chartInstance.config.data.datasets) || [];\n  }\n}\n","// @flow\n//\n//  Copyright (c) 2018-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\nimport ChartJSChart from \"chart.js\";\n\nimport installMulticolorLineChart from \"webviz-core/src/util/multicolorLineChart\";\n\nexport default function installChartjs(Chart: any = ChartJSChart) {\n  const annotationPlugin = require(\"chartjs-plugin-annotation\");\n  const datalabelPlugin = require(\"chartjs-plugin-datalabels\");\n  Chart.plugins.register(annotationPlugin);\n  Chart.plugins.register(datalabelPlugin);\n  installMulticolorLineChart(Chart);\n\n  // Otherwise we'd get labels everywhere.\n  Chart.defaults.global.plugins.datalabels = {};\n  Chart.defaults.global.plugins.datalabels.display = false;\n\n  if (Chart.plugins.count() !== 5) {\n    throw new Error(\n      \"Incorrect number of Chart.js plugins; one probably has not loaded correctly (make sure we don't have duplicate chart.js instances when running `yarn list`.\"\n    );\n  }\n}\n","// @flow\n//\n//  Copyright (c) 2018-present, Cruise LLC\n//\n//  This source code is licensed under the Apache License, Version 2.0,\n//  found in the LICENSE file in the root directory of this source tree.\n//  You may not use this file except in compliance with the License.\n\n/* eslint-disable no-underscore-dangle */\n// From https://github.com/chartjs/Chart.js/issues/4895#issuecomment-341874938\nexport default function installMulticolorLineChart(Chart: any) {\n  Chart.defaults.multicolorLine = Chart.defaults.scatter;\n  Chart.controllers.multicolorLine = Chart.controllers.scatter.extend({\n    draw(ease) {\n      let startIndex = 0;\n      const meta = this.getMeta();\n      const points = meta.data || [];\n      const colors = this.getDataset().colors;\n      const area = this.chart.chartArea;\n      const { multicolorLineYOffset } = this.chart.options.plugins || {};\n      if (multicolorLineYOffset) {\n        meta.dataset._children.forEach((data) => {\n          if (!data._view.originalY) {\n            data._view.originalY = data._view.y;\n          }\n          data._view.y = data._view.originalY + multicolorLineYOffset;\n        });\n      }\n      const originalDatasets = meta.dataset._children.filter((data) => {\n        return !isNaN(data._view.y);\n      });\n\n      function setColor(newColor, { dataset }) {\n        dataset._view.borderColor = newColor;\n      }\n\n      if (!colors) {\n        Chart.controllers.scatter.prototype.draw.call(this, ease);\n        return;\n      }\n\n      for (let i = 2; i <= colors.length; i++) {\n        if (colors[i - 1] !== colors[i]) {\n          setColor(colors[i - 1], meta);\n          meta.dataset._children = originalDatasets.slice(startIndex, i);\n          meta.dataset.draw();\n          startIndex = i - 1;\n        }\n      }\n\n      meta.dataset._children = originalDatasets.slice(startIndex);\n      meta.dataset.draw();\n      meta.dataset._children = originalDatasets;\n\n      points.forEach((point) => {\n        point.draw(area);\n      });\n    },\n  });\n}\n"],"sourceRoot":""}