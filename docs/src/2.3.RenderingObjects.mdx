import CodeSandboxEmbed from './jsx/utils/CodeSandboxEmbed.js';

# Rendering Objects

In this step, you'll learn how to:

- Build a Hello World app with Worldview
- Render objects with custom position, color, and scale
- Apply math equation to the rendered objects
- Use instanced rendering

## Building a Hello World App

Add `regl-worldview` to your package dependencies:

```json
"regl-worldview": "latest"
```

Create a new file titled `Example.js` in the `src/` directory, and add the code below which renders `Worldview` with a red cube and x/y/z axes:

```js
// src/Example.js
import React from "react";
import Worldview, { Cubes, Axes } from "regl-worldview";

export default function Example() {
  return (
    <Worldview>
      <Cubes>
        {[
          {
            pose: {
              orientation: { x: 0, y: 0, z: 0, w: 1 },
              // position the cube at the center
              position: { x: 0, y: 0, z: 0 },
            },
            scale: { x: 10, y: 10, z: 10 },
            // rgba values are between 0 and 1 (inclusive)
            // http://wiki.ros.org/rviz/DisplayTypes/Marker
            color: { r: 1, g: 0, b: 0, a: 1 },
          },
        ]}
      </Cubes>
      <Axes />
    </Worldview>
  );
}
```

Replace the contents of `src/index.js` with the following code to render your `Example` component:

```js
// src/index.js
import React from "react";
import ReactDOM from "react-dom";
import Example from "./Example";

function App() {
  return (
    <div style={{ width: "100vw", height: "100vh" }}>
      <Example />
    </div>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

Check your browser to see the red cube and axes – you have successfully created a Hello World app using Worldview!

You can interact with `Worldview` with the left click to move the scene, or right click to rotate the scene. Learn more about [controlling the camera with your keyboard](#/docs/api/worldview).

<CodeSandboxEmbed src="https://codesandbox.io/s/j7vo7yz3py" />

## Adding Objects with Custom Position, Scale, and Color

Let's make the app dynamic by using a button click to increment a `count` state, which will in turn add a corresponding number of cubes to the scene.

```js
// src/Example.js
export default function Example() {
  const [count, setCount] = useState(1);
  const markers = new Array(count).fill().map((_, idx) => {
    return {
      pose: {
        orientation: { x: 0, y: 0, z: 0, w: 1 },
        // change cube's position along x axis
        position: { x: idx * idx, y: 0, z: 0 },
      },
      scale: { x: idx + 1, y: idx + 1, z: idx + 1 },
      // set cube to a random color
      color: { r: Math.random(), g: Math.random(), b: Math.random(), a: 1 },
    };
  });

  return (
    <Worldview>
      <button style={{ position: "absolute", top: 0, left: 0 }} onClick={() => setCount(count + 1)}>
        Add a Cube
      </button>
      <Cubes>{markers}</Cubes>
      <Axes />
    </Worldview>
  );
}
```

Whenever you click the "Add a Cube” button, you'll see a new cube with a randomly generated color added to the scene.

<CodeSandboxEmbed src="https://codesandbox.io/s/lxzrxqlpym" />

## Rendering a Colorful Knot

A [trefoil](https://en.wikipedia.org/wiki/Trefoil_knot) knot is obtained by joining the 2 loose ends of a common overhand knot, resulting in a knotted loop. In this step, let's apply the parametric equations of a trefoil knot and add color variations.

```js
// src/Example.js
function Example() {
  const steps = 500; // total number of objects

  // map a number/index to a specific color
  function numberToColor(number, max, a = 1) {
    const i = (number * 255) / max;
    const r = Math.round(Math.sin(0.024 * i + 0) * 127 + 128) / 255;
    const g = Math.round(Math.sin(0.024 * i + 2) * 127 + 128) / 255;
    const b = Math.round(Math.sin(0.024 * i + 4) * 127 + 128) / 255;
    return { r, g, b, a };
  }

  // the object index needs to be multipled by this scale so it's evenly distributed in the space
  const scale = (Math.PI * 2) / steps;
  const markers = new Array(steps)
    .fill()
    .map((_, idx) => [
      // generate x, y, z coordinates based on trefoil equation
      Math.sin(idx * scale) + 2 * Math.sin(2 * idx * scale),
      Math.cos(idx * scale) - 2 * Math.cos(2 * idx * scale),
      -Math.sin(3 * idx * scale),
    ])
    .map(([x, y, z], idx) => ({
      pose: {
        orientation: { x: 0, y: 0, z: 0, w: 1 },
        position: { x: 20 * x, y: 20 * y, z: 20 * z },
      },
      scale: { x: 1, y: 1, z: 1 },
      color: numberToColor(idx, steps),
    }));

  return (
    <Worldview>
      <Spheres>{markers}</Spheres>
      <Axes />
    </Worldview>
  );
}
```

<CodeSandboxEmbed src="https://codesandbox.io/s/2x26ov87j0" />

## Improving Performance with Instanced Rendering

When drawing many instances of the same object, you'll quickly reach a performance bottleneck with the number of GPU calls. [Instancing](https://learnopengl.com/Advanced-OpenGL/Instancing) allows us to draw many objects at once with a single render call, saving us valuable CPU -> GPU communication time.

Most of the existing [Commands](#/docs/api/command) support instancing. In this step, let's convert our previous example to use instanced rendering.

```js
// src/Example.js
function Example() {
  // ... other existing code
  new Array(steps)
    .fill()
    .map((_, idx) => [
      // generate x, y, z coordinates based on trefoil equation
      Math.sin(idx * scale) + 2 * Math.sin(2 * idx * scale),
      Math.cos(idx * scale) - 2 * Math.cos(2 * idx * scale),
      -Math.sin(3 * idx * scale),
    ])
    .forEach(([x, y, z], idx) => {
      // add individual point and color to the single sphere object
      marker.colors.push(numberToColor(idx, steps));
      marker.points.push({ x: x * 20, y: y * 20, z: z * 20 });
    });

  return (
    <Worldview>
      <Spheres>{[marker]}</Spheres>
      <Axes />
    </Worldview>
  );
}
```

In our new example, we are rendering a single marker with 500 colors and points, instead of 500 separate markers. This change will save us a significant amount of CPU -> GPU communication time!

<CodeSandboxEmbed src="https://codesandbox.io/s/jl9qv2mjyy" />

Next: [Managing the Camera](#/docs/tutorial/managing-the-camera)
