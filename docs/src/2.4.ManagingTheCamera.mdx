import CodeSandboxEmbed from './jsx/utils/CodeSandboxEmbed.js';

# Managing Camera

In this chapter, you'll learn how to:

- Control camera position and other state
- Update the camera to follow object movements

## Moving the Camera

The WebGL camera uses a [perspective projection](https://webglfundamentals.org/webgl/lessons/webgl-3d-perspective.html) to mimic the way a human eye sees. Worldview has a simple `cameraState` API that abstracts away much of the math needed to control the camera. Read the [Camera docs](#/docs/api/camera) and explore the playground to learn more.

In this step, we'll add a duck model to the center of the scene, and move the camera to observe the duck from different angles.

First, let's create a `Duck` component using [GLTFScene](#/docs/commands/gltfscene), and add the `Duck.glb` model file to the `src/utils` folder. Later we'll compose this `Duck` with other commands.

```js
// src/Duck.js
import React from "react";
import { GLTFScene } from "regl-worldview";
import duckModel from "./utils/Duck.glb";

export default function Duck() {
  return (
    <GLTFScene model={duckModel}>
      {{
        pose: {
          position: { x: 0, y: 0, z: 0 },
          orientation: { x: 0, y: 0, z: 0, w: 1 },
        },
        scale: { x: 3, y: 3, z: 3 },
      }}
    </GLTFScene>
  );
}
```

To move the camera, we will need to store some state that changes over time. Let's add a [React Hook](https://reactjs.org/docs/hooks-intro.html) that accepts a callback which will be called at each timestep. We'll use [window.requestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame) to keep our state updates in sync with the display refresh rate.

```js
// src/utils/useRequestAnimationFrame.js
import { useLayoutEffect, useRef, useEffect, useCallback } from "react";

// a react hook that accepts a callback function which will be called before each browser repaint
export default function useRequestAnimationFrame(callback) {
  // use ref so the callback will persist for the full lifetime of the component
  const callbackRef = useRef(callback);
  // only update callbackRef when the callback changes
  useEffect(() => (callbackRef.current = callback), [callback]);

  // persist the requestAnimationFrameId so the last refresh callback can be cancelled when component unmounts
  const rafId = useRef();
  // the function to be called in every requrestAnimationFrame
  function loop() {
    rafId.current = requestAnimationFrame(loop);
    callbackRef.current();
  }

  // start the loop when the component mounts and cancel the animation frame when unmounts
  useEffect(() => {
    rafId.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(rafId.current);
  }, []);
}
```

Lastly, let's put everything together. Each frame, when our `useRequestAnimationFrame` callback is called, we'll increase a counter by 1, and use the counter to adjust the camera's `phi` and `thetaOffset`.

```js
// src/Example.js

import Duck from "./Duck";
import useRequestAnimationFrame from "./utils/useRequestAnimationFrame";

export default function Example() {
  const cameraMoveSpeed = 1 / 100;
  // use count to derive camera phi and thetaOffset values
  const [count, setCount] = useState(0);
  useRequestAnimationFrame(() => {
    // update count before each browser repaint
    const newCount = count + 2 >= steps ? 0 : count + 1;
    setCount(newCount);
  });

  // generate cameraState from `count`
  const cameraState = {
    ...DEFAULT_CAMERA_STATE,
    phi: count * cameraMoveSpeed * Math.PI,
    thetaOffset: count * cameraMoveSpeed * 2 * Math.PI,
  };

  // ...other existing code

  return (
    <Worldview cameraState={cameraState}>
      <Spheres>{[marker]}</Spheres>
      <Axes />
      <Duck />
    </Worldview>
  );
}
```

Now the camera is moving around the scene, giving us a 360° view of the duck model!

Notice that we've added `cameraState={cameraState}`, which turns `Worldview` into a [controlled component](https://reactjs.org/docs/forms.html). Controlled components usually require an `onChange` handler, but no `onCameraStateChange` prop is needed for our example, since we don't need to do anything with the new `cameraState` value.

<CodeSandboxEmbed src="https://codesandbox.io/s/qx5zrko8nj" />

## Follow an Object

In this step, let's move the duck along our knot, and move the camera to follow the duck around as it travels.

Let's first modify the Duck component to accept children, so that the duck's position can be updated dynamically:

```js
// src/Duck.js
const DEFAULT_CHILDREN = {
  pose: {
    position: { x: 0, y: 0, z: 0 },
    orientation: { x: 0, y: 0, z: 0, w: 1 },
  },
  scale: { x: 3, y: 3, z: 3 },
};

export default function Example({ children = DEFAULT_CHILDREN }) {
  return <GLTFScene model={duckModel}>{children}</GLTFScene>;
}
```

Next, let's remove the camera setting for `thetaOffset` and `phi`, so that we don't get dizzy watching the scene while the duck moves. We can derive the duck's position from the spheres over time, and use the duck position as `target` input for `cameraState`.

```js
// src/Example.js

export default function Example() {
  // ... other existing code
  // move the duck along the knot by extracting the sphere position over time
  const duckPosition = marker.points[count % steps];
  // generate cameraState from `count`
  const cameraState = {
    ...DEFAULT_CAMERA_STATE,
    // This is the magic! Simply supply the target position and the camera will follow
    target: [duckPosition.x, duckPosition.y, duckPosition.z],
    // zoom out a little so we can see better
    distance: 120,
  };

  return (
    <Worldview cameraState={cameraState}>
      <Spheres>{[marker]}</Spheres>
      <Axes />
      <Duck>
        {{
          pose: {
            position: duckPosition,
            orientation: { x: 0, y: 0, z: 0, w: 1 },
          },
          scale: { x: 3, y: 3, z: 3 },
        }}
      </Duck>
    </Worldview>
  );
}
```

Voilà! By adding the `target` position to `cameraState`, the camera now follows the duck around!

<CodeSandboxEmbed src="https://codesandbox.io/s/71k2xzj8ox" />

Next, let's [make our scene interactive](#/docs/tutorial/adding-interactivity) by handling mouse events.
