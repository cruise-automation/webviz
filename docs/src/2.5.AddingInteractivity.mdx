import CodeSandboxEmbed from './jsx/utils/CodeSandboxEmbed.js';

# Adding Interactivity

In this step, you'll learn how to:

- Set up the marker input for hitmap/mouse interaction
- Interact with the scene through event handlers
- Retrieve object and event information from the event handlers

## Adding and Removing Obstacles along the Duck's Path

In previous steps, you've learned how to interact with Worldview through mouse, keyboard, and programatic controls, all of which affect the camera. Worldiview and its Commmand components also support other [Mouse Events](#/docs/api/mouse-events), such `onClick`, `onDoubleClick`, `onMouseDown`, `onMouseMove`, and `onMouseUp`. 

In this step, let's place red Cubes as obstacles along the duck's path. When the duck hits an obstacle, it should stop moving until you removed the blocking obstacle.

First, let's add an `id` field to the Sphere marker to enable a hitmap and identify the Sphere being clicked.

```js
const marker = {
  // hitmap support requires unique positive integer id
  id: 101,
  pose: {
    orientation: { x: 0, y: 0, z: 0, w: 1 },
    position: { x: 0, y: 0, z: 0 },
  },
  scale: { x: 1, y: 1, z: 1 },
  colors: [],
  points: [],
};
```

Let's also enable manual camera movement, so we can see the duck better.

```js
<Worldview defaultCameraState={{ ...DEFAULT_CAMERA_STATE, distance: 120 }}>
```

Next, let's add a `clickedObjectIds` state to keep track of the clicked Spheres. We'll also use this `clickedObjectIds` state to generate Cube obstacles.

```js
const [clickedObjectIds, setClickedObjectIds] = useState(new Set());

const obstacleMarkers = Array.from(clickedObjectIds).map((clickedObjectId, index) => {
  const pointIdx = clickedObjectId - marker.id;
  const position = marker.points[pointIdx];
  return {
    //keep the id unique by adding sphere's id range as offset: marker.id + steps
    id: marker.id + steps + index,
    // remember the original clickedObjectId so when the obstacle is clicked, we can
    // remove the obstacle quickly by update clickedObjectIds
    clickedObjectId,
    pose: {
      orientation: { x: 0, y: 0, z: 0, w: 1 },
      position: position,
    },
    color: { r: 1, g: 0, b: 0, a: 1 }, // red
    scale: { x: 4, y: 4, z: 4 }, // scale up a little so it's bigger than the spheres
  };
});
```

Now, let's use the clicked Sphere id to update the `clickedObjectIds` state, which will be consumed by the Cube obstacles. Clicking each obstacle should remove it from the scene.

```js
 <Spheres
    onClick={(ev, { objectId, object }) => {
        // Click once to add obstacle. Even though both the small Sphere and the big Obstacle cube have
        // hitmap enabled, clicking again will only trigger `onClick` event on the Cube because it's a lot bigger
        clickedObjectIds.add(objectId);
        setClickedObjectIds(new Set(clickedObjectIds));
    }}>
    {[marker]}
    </Spheres>
    <Cubes
        onClick={(ev, { objectId, object }) => {
            // the `object` contains information of the clicked Cube, which has `clickedObjectId`
            clickedObjectIds.delete(object.clickedObjectId);
            setClickedObjectIds(new Set(clickedObjectIds));
        }}>
        {obstacleMarkers}
    </Cubes>
```

Lastly, setting an `isDuckStopped` variable will allow us to tell the duck when to stop and when to move forward. 

```js
// keep track whethere we need to stop the duck from moving
let isDuckStopped = false;
useRequestAnimationFrame(() => {
  if (!isDuckStopped) {
    // update count before each browser repaint
    const newCount = count >= 100000 ? 0 : count + 1;
    setCount(newCount);
  }
});

obstacleMarkers.forEach((marker) => {
  const position = marker.pose.position;
  // make the duck stop when the duck's current position has an obstacle
  if (position.x === duckPosition.x && position.y === duckPosition.y && position.z === duckPosition.z) {
    isDuckStopped = true;
  }
});
s;
```

Put it all together, and we now have a moving duck that gets stuck on every Cube obstacle in its path. Clicking a blocking Cube will remove it, allowing the duck to happily continue forward.

<CodeSandboxEmbed src="https://codesandbox.io/s/j7n5r2mkr3" />

## Next Steps

Congratulations on finishing this tutorial, and building your first  `regl-worldview` app! To learn more:

- Read the [API docs](#/docs/api) to learn common APIs for Worldview, the camera, mouse interaction, type support, etc.
- Read about supported WebGL [commands](#/docs/commands) â€“ Cubes, Spheres, Triangles, Lines, etc.
